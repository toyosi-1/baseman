<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BLUE MAN â€” Base Runner</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{
    background:#07121a;
    color:#00d1ff;
    font-family:'Courier New',monospace;
    display:flex;align-items:center;justify-content:center;
    min-height:100vh;padding:20px;
  }
  .container{width:560px;position:relative}
  canvas{
    display:block;background:#000;border:4px solid #003a66;
    border-radius:8px;box-shadow:0 0 40px rgba(0,82,255,0.12);
    image-rendering:pixelated;
  }
  .hud{display:flex;justify-content:space-between;align-items:center;margin-top:12px;
       background:rgba(0,82,255,0.04);padding:8px;border-radius:6px;border:1px solid rgba(0,82,255,0.08)}
  .hud div{font-weight:700;font-size:14px}
  .panel{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
  .center-panel{background:rgba(8,10,14,0.98);padding:18px;border-radius:8px;text-align:center;color:#fff;max-width:360px}
  button{background:linear-gradient(45deg,#0052FF,#00D1FF);border:none;padding:10px 16px;border-radius:6px;color:#fff;font-weight:700;cursor:pointer}
  .hidden{display:none}
  .powerbar{width:120px;height:8px;background:rgba(255,255,255,0.06);border-radius:4px;overflow:hidden;position:relative}
  .powerbar>i{display:block;height:100%;background:linear-gradient(90deg,#00D1FF,#88FFFF);width:0%;transition:width 0.1s linear}
  .powerbar.flash>i{animation:flash 0.4s infinite alternate}
  @keyframes flash{from{opacity:1;}to{opacity:0.3;}}
  /* Mint banner */
  .mint-banner{
    position:fixed;left:50%;transform:translateX(-50%);
    bottom:22px;background:linear-gradient(90deg,#002F6C,#0040A8);
    color:#fff;padding:10px 14px;border-radius:8px;box-shadow:0 6px 24px rgba(0,0,0,0.6);
    display:flex;gap:10px;align-items:center;z-index:1000;
  }
  .mint-banner.hidden{display:none}
  .mint-banner button{background:#fff;color:#0040A8;padding:6px 10px;border-radius:6px;font-weight:800}
</style>
</head>
<body>
  <div class="container">
    <canvas id="gameCanvas" width="560" height="620"></canvas>

    <div id="gameStart" class="panel">
      <div class="center-panel">
        <h2 style="margin-bottom:6px">ðŸŸ¦ BLUE MAN â€” Base Runner</h2>
        <p style="max-width:360px;margin:8px auto 12px">
          Arrow keys to move. Collect <strong>TX Orbs</strong>. Use <strong>Consensus Cores</strong> (power pellets) to subdue corrupted nodes.
        </p>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:8px">
          <button id="startButton">START GAME</button>
        </div>
      </div>
    </div>

    <div id="gameOver" class="panel hidden">
      <div class="center-panel">
        <h2 id="gameOverTitle">GAME OVER</h2>
        <p>Final Score: <strong id="finalScore">0</strong></p>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:8px">
          <button id="restartButton">PLAY AGAIN</button>
        </div>
      </div>
    </div>

    <div class="hud">
      <div>HASH POWER: <span id="score">0</span></div>
      <div>SESSION KEYS: <span id="lives">3</span></div>
      <div>HIGH: <span id="highScore">0</span></div>
      <div style="display:flex;align-items:center;gap:8px">POWER <div class="powerbar" aria-hidden="true"><i id="powerFill"></i></div></div>
    </div>
  </div>

  <!-- mint banner -->
  <div id="mintBanner" class="mint-banner hidden" role="status" aria-live="polite">
    <div><strong>Mint Unlocked!</strong> You reached the mint threshold.</div>
    <div style="margin-left:8px">
      <button id="claimMintBtn">Claim Mint</button>
      <button id="closeMintBtn" style="margin-left:8px;background:transparent;border:1px solid rgba(255,255,255,0.12);color:#fff">Close</button>
    </div>
  </div>

<script>
/* ---------------- CONFIG ---------------- */
const TILE_SIZE = 20;
const CANVAS_WIDTH = 560;
const CANVAS_HEIGHT = 620;
const GRID_WIDTH = CANVAS_WIDTH / TILE_SIZE;
const GRID_HEIGHT = CANVAS_HEIGHT / TILE_SIZE;
let PACMAN_SPEED = 2.8;        // slight reduction for fairness
let GHOST_SPEED = 1.9;         // increased difficulty
const POWER_MODE_DURATION_FRAMES = 240; // ~4s shorter, harder
const GHOST_SCATTER_DURATION = 240;
const GHOST_CHASE_DURATION = 540;
const GHOST_RANDOM_TURN_CHANCE = 0.005; // rarer random turns

// MINT CONFIG
const MINT_SCORE_THRESHOLD = 15000;
let mintUnlocked = false;

/* ---------------- STATE ---------------- */
let canvas, ctx;
let animationId = null;
let gameActive = false;
let score = 0;
let lives = 3;
let highScore = parseInt(localStorage.getItem('BlueManHighScore')) || 0;
let powerMode = false;
let powerTimer = 0;

let pacman = { x:0,y:0,direction:'right',nextDirection:'right',speed:PACMAN_SPEED,mouthOpen:0,mouthDir:1 };
let ghosts = [], dots = [], powerPellets = [], walls = [];

/* ---------------- MAZE ---------------- */
/* Maze 31 rows x 28 cols (same as earlier) */
const maze = [
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
[1,2,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,2,1],
[1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],
[1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],
[1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],
[1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1],
[1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1],
[1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1],
[1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,1],
[1,1,1,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,1,1],
[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],
[1,1,1,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,1,1],
[1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1],
[1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1],
[1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1],
[1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
[1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
[1,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,2,1],
[1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],
[1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],
[1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],
[1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],
[1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

/* ---------------- HELPERS ---------------- */
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(ax,ay,bx,by){ return Math.hypot(ax-bx,ay-by); }
function isCentered(entity){
  // check if entity is near tile center (for smoother direction changes)
  const cx = (entity.x + TILE_SIZE/2);
  const cy = (entity.y + TILE_SIZE/2);
  return (Math.abs((cx % TILE_SIZE) - TILE_SIZE/2) < 1.2) && (Math.abs((cy % TILE_SIZE) - TILE_SIZE/2) < 1.2);
}

/* ---------------- DRAW HELPERS (Base theme) ---------------- */
function drawHex(x,y){
  // glowing block for walls
  ctx.fillStyle = '#031727';
  ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);
  ctx.strokeStyle = 'rgba(0,210,255,0.12)';
  ctx.lineWidth = 1;
  ctx.strokeRect(x+1,y+1,TILE_SIZE-2,TILE_SIZE-2);
}
function drawDot(x,y){
  ctx.fillStyle = '#00d1ff';
  ctx.beginPath(); ctx.arc(x+TILE_SIZE/2,y+TILE_SIZE/2,3,0,Math.PI*2); ctx.fill();
}
function drawPower(x,y,t=0){
  // rotating-ish glowing square (Consensus Core)
  const cx = x + TILE_SIZE/2, cy = y + TILE_SIZE/2;
  const s = 6;
  const rot = (t % 360) * Math.PI/180;
  ctx.save();
  ctx.translate(cx,cy);
  ctx.rotate(rot * 0.4);
  ctx.fillStyle = 'rgba(0,210,255,0.92)';
  ctx.fillRect(-s/2,-s/2,s,s);
  ctx.restore();
  // soft glow
  ctx.beginPath();
  ctx.fillStyle = 'rgba(0,210,255,0.06)';
  ctx.arc(cx,cy,12,0,Math.PI*2);
  ctx.fill();
}
function drawBlueCore(x,y,dir,mouthOpen,t=0){
  // radial gradient core + subtle pulse
  const cx = x + TILE_SIZE/2, cy = y + TILE_SIZE/2;
  const rCore = 8;
  const pulse = 0.92 + 0.08 * Math.sin(t * 0.12);
  const g = ctx.createRadialGradient(cx,cy,1,cx,cy,rCore*2);
  g.addColorStop(0,'rgba(255,255,255,0.95)');
  g.addColorStop(0.15,'rgba(150,240,255,0.95)');
  g.addColorStop(0.35,'rgba(0,208,255,0.9)');
  g.addColorStop(1,'rgba(0,30,70,0.6)');
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(cx,cy,rCore * pulse,0,Math.PI*2); ctx.fill();
  // outer aura
  ctx.beginPath(); ctx.fillStyle = 'rgba(0,200,255,0.08)'; ctx.arc(cx,cy,rCore*3*pulse,0,Math.PI*2); ctx.fill();
}
function drawGhost(x,y,index,state){
  const colors = ['#ff6b6b','#9affb8','#6fdfff','#ffcf66'];
  const syms = ['Îž','â—Ž','âŸ ','âšŒ'];
  const cx = x + TILE_SIZE/2, cy = y + TILE_SIZE/2;
  ctx.fillStyle = state === 'vulnerable' ? '#0052FF' : colors[index % colors.length];
  ctx.beginPath();
  ctx.arc(cx,cy-2,7,Math.PI,0,false);
  ctx.lineTo(cx+7,cy+5); ctx.lineTo(cx+3,cy+8); ctx.lineTo(cx,cy+5);
  ctx.lineTo(cx-3,cy+8); ctx.lineTo(cx-7,cy+5);
  ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(cx-3,cy-3,2,0,Math.PI*2); ctx.arc(cx+3,cy-3,2,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = state === 'vulnerable' ? '#0000FF' : '#000';
  ctx.beginPath(); ctx.arc(cx-3,cy-3,1,0,Math.PI*2); ctx.arc(cx+3,cy-3,1,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#000';
  ctx.font = 'bold 8px Arial'; ctx.textAlign='center'; ctx.fillText(syms[index%syms.length], cx, cy+4);
}

/* ---------------- INIT ---------------- */
function init(){
  canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');
  document.getElementById('highScore').textContent = highScore;
  setupEventListeners();
  drawPreview(); // draw preview so canvas isn't empty
}

function setupEventListeners(){
  document.getElementById('startButton').addEventListener('click', startGame);
  document.getElementById('restartButton').addEventListener('click', startGame);
  document.getElementById('claimMintBtn').addEventListener('click', claimMint);
  document.getElementById('closeMintBtn').addEventListener('click', ()=>document.getElementById('mintBanner').classList.add('hidden'));
  document.addEventListener('keydown', handleKeyPress);
}

function drawPreview(){
  ctx.fillStyle = '#07121a'; ctx.fillRect(0,0,canvas.width,canvas.height);
  for(let y=0;y<maze.length;y++){
    for(let x=0;x<maze[y].length;x++){
      if(maze[y][x] === 1) drawHex(x*TILE_SIZE,y*TILE_SIZE);
      else if(maze[y][x] === 0) drawDot(x*TILE_SIZE,y*TILE_SIZE);
      else if(maze[y][x] === 2) drawPower(x*TILE_SIZE,y*TILE_SIZE,0);
    }
  }
}

/* ---------------- GAME CONTROL ---------------- */
function startGame(){
  gameActive = true;
  document.getElementById('gameStart').classList.add('hidden');
  document.getElementById('gameOver').classList.add('hidden');
  resetGame();
  if(animationId) cancelAnimationFrame(animationId);
  animationId = requestAnimationFrame(gameLoop);
}

function resetGame(){
  score = 0;
  lives = 3;
  powerMode = false;
  powerTimer = 0;
  dots = []; powerPellets = []; walls = [];
  for(let y=0;y<maze.length;y++){
    for(let x=0;x<maze[y].length;x++){
      const v = maze[y][x];
      if(v === 0) dots.push({x:x*TILE_SIZE, y:y*TILE_SIZE});
      else if(v === 2) powerPellets.push({x:x*TILE_SIZE, y:y*TILE_SIZE});
      else if(v === 1) walls.push({x:x*TILE_SIZE, y:y*TILE_SIZE});
    }
  }
  pacman.x = 14*TILE_SIZE; pacman.y = 23*TILE_SIZE;
  pacman.direction = 'right'; pacman.nextDirection = 'right'; pacman.mouthOpen = 0; pacman.mouthDir = 1;

  ghosts = [
    {x:13*TILE_SIZE,y:11*TILE_SIZE,direction:'left',speed:GHOST_SPEED,state:'normal',respawnTimer:0,mode:'scatter',modeTimer:GHOST_SCATTER_DURATION, lastDirChangeTick:0},
    {x:14*TILE_SIZE,y:11*TILE_SIZE,direction:'up',speed:GHOST_SPEED,state:'normal',respawnTimer:0,mode:'scatter',modeTimer:GHOST_SCATTER_DURATION, lastDirChangeTick:0},
    {x:15*TILE_SIZE,y:11*TILE_SIZE,direction:'right',speed:GHOST_SPEED,state:'normal',respawnTimer:0,mode:'scatter',modeTimer:GHOST_SCATTER_DURATION, lastDirChangeTick:0},
    {x:13*TILE_SIZE,y:14*TILE_SIZE,direction:'left',speed:GHOST_SPEED,state:'normal',respawnTimer:0,mode:'scatter',modeTimer:GHOST_SCATTER_DURATION, lastDirChangeTick:0}
  ];

  document.getElementById('powerFill').style.width = '0%';
  updateHUD();
}

/* ---------------- INPUT ---------------- */
function handleKeyPress(e){
  if(!gameActive) return;
  switch(e.key){
    case 'ArrowUp': pacman.nextDirection = 'up'; break;
    case 'ArrowDown': pacman.nextDirection = 'down'; break;
    case 'ArrowLeft': pacman.nextDirection = 'left'; break;
    case 'ArrowRight': pacman.nextDirection = 'right'; break;
  }
}

/* ---------------- HUD ---------------- */
function updateHUD(){
  document.getElementById('score').textContent = score;
  document.getElementById('lives').textContent = lives;
  document.getElementById('highScore').textContent = highScore;
}

/* ---------------- GAME LOOP ---------------- */
let frameTick = 0;
function gameLoop(ts){
  if(!gameActive) return;
  frameTick++;
  ctx.fillStyle = '#07121a'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw maze
  walls.forEach(w => drawHex(w.x,w.y));
  dots.forEach(d => drawDot(d.x,d.y));
  // pass frameTick into power draw for rotation
  for(let i=0;i<powerPellets.length;i++){ drawPower(powerPellets[i].x, powerPellets[i].y, frameTick + i*10); }

  // update & draw
  updatePacman(frameTick);
  updateGhosts(frameTick);

  // collisions & UI
  checkCollisions();
  updatePowerBar();

  if(dots.length === 0 && powerPellets.length === 0){
    score += 1000;
    levelComplete();
    return;
  }

  animationId = requestAnimationFrame(gameLoop);
}

/* ---------------- MOVEMENT & COLLISIONS HELPERS ---------------- */
function canMove(x,y,direction,speed){
  let nx = x, ny = y;
  switch(direction){
    case 'up': ny -= speed; break;
    case 'down': ny += speed; break;
    case 'left': nx -= speed; break;
    case 'right': nx += speed; break;
  }
  const corners = [
    {x: nx + 2, y: ny + 2},
    {x: nx + TILE_SIZE - 2, y: ny + 2},
    {x: nx + 2, y: ny + TILE_SIZE - 2},
    {x: nx + TILE_SIZE - 2, y: ny + TILE_SIZE - 2}
  ];
  for(const c of corners){
    const gx = Math.floor(c.x / TILE_SIZE);
    const gy = Math.floor(c.y / TILE_SIZE);
    if(gx < 0 || gx >= GRID_WIDTH || gy < 0 || gy >= GRID_HEIGHT) continue;
    if(maze[gy][gx] === 1) return false;
  }
  return true;
}

/* ---------------- PACMAN UPDATE ---------------- */
function updatePacman(t){
  // mouth animation
  pacman.mouthOpen += 0.12 * pacman.mouthDir;
  if(pacman.mouthOpen >= 1 || pacman.mouthOpen <= 0) pacman.mouthDir *= -1;

  // attempt to change direction if possible
  if(canMove(pacman.x, pacman.y, pacman.nextDirection, pacman.speed)){
    pacman.direction = pacman.nextDirection;
  }

  // move in direction if allowed
  if(canMove(pacman.x, pacman.y, pacman.direction, pacman.speed)){
    switch(pacman.direction){
      case 'up': pacman.y -= pacman.speed; break;
      case 'down': pacman.y += pacman.speed; break;
      case 'left': pacman.x -= pacman.speed; break;
      case 'right': pacman.x += pacman.speed; break;
    }
  }

  // tunnel wrap (left-right)
  if(pacman.x < -TILE_SIZE) pacman.x = CANVAS_WIDTH - TILE_SIZE;
  else if(pacman.x > CANVAS_WIDTH - TILE_SIZE) pacman.x = -TILE_SIZE + 0.5;

  drawBlueCore(pacman.x, pacman.y, pacman.direction, pacman.mouthOpen, t);
}

/* ---------------- GHOSTS: improved AI + respawn ---------------- */
function updateGhosts(t){
  ghosts.forEach((g,idx) => {
    // If eaten: wait respawnTimer, then move back to lair gradually
    if(g.state === 'eaten'){
      if(g.respawnTimer > 0){
        g.respawnTimer--;
      } else {
        const lairX = 13*TILE_SIZE + (idx % 2) * TILE_SIZE;
        const lairY = (idx === 3 ? 14 : 11) * TILE_SIZE;
        const dx = lairX - g.x, dy = lairY - g.y;
        const d = Math.hypot(dx,dy);
        const step = Math.min(g.speed, d);
        if(d > 1){
          g.x += (dx / d) * step;
          g.y += (dy / d) * step;
          drawGhost(g.x, g.y, idx, true);
          return;
        } else {
          g.x = lairX; g.y = lairY; g.state = 'normal';
          g.mode = 'scatter'; g.modeTimer = GHOST_SCATTER_DURATION;
        }
      }
    }

    // set vulnerable if powerMode active
    if(powerMode && g.state !== 'eaten') g.state = 'vulnerable';
    else if(g.state !== 'eaten') g.state = 'normal';

    // mode timers
    if(!g.mode) g.mode = 'scatter';
    if(typeof g.modeTimer !== 'number') g.modeTimer = GHOST_SCATTER_DURATION;
    g.modeTimer--;
    if(g.modeTimer <= 0){
      if(g.mode === 'scatter'){ g.mode = 'chase'; g.modeTimer = GHOST_CHASE_DURATION; }
      else { g.mode = 'scatter'; g.modeTimer = GHOST_SCATTER_DURATION; }
    }

    // Decide when to pick a new direction:
    const centered = isCentered(g);
    const now = t || frameTick;
    // prevent too-frequent direction changes: require center or > 20 frames since last change
    const canConsider = centered || (now - (g.lastDirChangeTick || 0) > 20);

    if(canConsider){
      // choose target (chase / scatter / flee)
      let targetX, targetY;
      if(g.state === 'vulnerable'){
        targetX = CANVAS_WIDTH - pacman.x;
        targetY = CANVAS_HEIGHT - pacman.y;
      } else if(g.mode === 'chase'){
        targetX = pacman.x; targetY = pacman.y;
      } else {
        const corners = [
          {x: 0, y: 0},
          {x: CANVAS_WIDTH - TILE_SIZE, y: 0},
          {x: CANVAS_WIDTH - TILE_SIZE, y: CANVAS_HEIGHT - TILE_SIZE},
          {x: 0, y: CANVAS_HEIGHT - TILE_SIZE}
        ];
        targetX = corners[idx].x; targetY = corners[idx].y;
      }

      // evaluate directions
      const dirs = ['up','down','left','right'];
      let bestDir = g.direction;
      let bestMetric = (g.state === 'vulnerable') ? -Infinity : Infinity;

      dirs.forEach(d => {
        if(!canMove(g.x, g.y, d, g.speed)) return;
        let nx = g.x, ny = g.y;
        switch(d){ case 'up': ny -= g.speed; break; case 'down': ny += g.speed; break; case 'left': nx -= g.speed; break; case 'right': nx += g.speed; break; }
        const distance = dist(nx,ny,targetX,targetY);
        if(g.state === 'vulnerable'){
          if(distance > bestMetric){ bestMetric = distance; bestDir = d; }
        } else {
          if(distance < bestMetric){ bestMetric = distance; bestDir = d; }
        }
      });

      // small chance to pick a random valid direction (but rare)
      if(Math.random() < GHOST_RANDOM_TURN_CHANCE){
        const valids = dirs.filter(d => canMove(g.x,g.y,d,g.speed));
        if(valids.length) bestDir = valids[Math.floor(Math.random()*valids.length)];
      }

      if(bestDir !== g.direction){
        g.direction = bestDir;
        g.lastDirChangeTick = now;
      }
    }

    // Move ghost according to direction
    if(canMove(g.x,g.y,g.direction,g.speed)){
      const sp = (g.state === 'vulnerable') ? g.speed * 0.55 : g.speed;
      switch(g.direction){
        case 'up': g.y -= sp; break;
        case 'down': g.y += sp; break;
        case 'left': g.x -= sp; break;
        case 'right': g.x += sp; break;
      }
    } else {
      // If cannot move, mark lastDirChangeTick so AI won't immediately try again wildly
      g.lastDirChangeTick = (g.lastDirChangeTick || frameTick);
    }

    // wrap edges
    if(g.x < -TILE_SIZE) g.x = CANVAS_WIDTH - TILE_SIZE;
    else if(g.x > CANVAS_WIDTH - TILE_SIZE) g.x = -TILE_SIZE + 0.5;

    drawGhost(g.x, g.y, idx, g.state === 'vulnerable');
  });
}

/* ---------------- COLLISIONS ---------------- */
function checkCollisions(){
  // dots
  for(let i=dots.length-1;i>=0;i--){
    const d = dots[i];
    if(dist(d.x + TILE_SIZE/2, d.y + TILE_SIZE/2, pacman.x + TILE_SIZE/2, pacman.y + TILE_SIZE/2) < 10){
      dots.splice(i,1); score += 10;
    }
  }

  // power pellets
  for(let i=powerPellets.length-1;i>=0;i--){
    const p = powerPellets[i];
    if(dist(p.x + TILE_SIZE/2, p.y + TILE_SIZE/2, pacman.x + TILE_SIZE/2, pacman.y + TILE_SIZE/2) < 12){
      powerPellets.splice(i,1); score += 50; enterPowerMode();
    }
  }

  // ghosts
  ghosts.forEach(g => {
    if(g.state === 'eaten') return;
    const d = dist(g.x + TILE_SIZE/2, g.y + TILE_SIZE/2, pacman.x + TILE_SIZE/2, pacman.y + TILE_SIZE/2);
    if(d < 15){
      if(g.state === 'vulnerable'){
        g.state = 'eaten';
        g.respawnTimer = 60 + Math.floor(Math.random() * 120); // 1-3s delay before moving back to lair
        score += 200;
        g.x = 13 * TILE_SIZE; g.y = 11 * TILE_SIZE;
      } else {
        loseLife();
      }
    }
  });

  // mint threshold
  if(!mintUnlocked && score >= MINT_SCORE_THRESHOLD){
    mintUnlocked = true;
    document.getElementById('mintBanner').classList.remove('hidden');
  }

  updateHUD();

  if(dots.length === 0 && powerPellets.length === 0){
    score += 1000;
    levelComplete();
  }
}

/* ---------------- POWER MODE ---------------- */
function enterPowerMode(){
  powerMode = true;
  powerTimer = POWER_MODE_DURATION_FRAMES;
  ghosts.forEach(g => { if(g.state !== 'eaten') g.state = 'vulnerable'; });
  document.getElementById('powerFill').style.width = '100%';
  document.querySelector('.powerbar').classList.remove('flash');
}
function updatePowerBar(){
  const fillEl = document.getElementById('powerFill');
  const barEl = fillEl.parentElement;
  if(powerMode){
    powerTimer--;
    const pct = clamp((powerTimer / POWER_MODE_DURATION_FRAMES) * 100, 0, 100);
    fillEl.style.width = pct + '%';
    if(powerTimer <= 60) barEl.classList.add('flash'); else barEl.classList.remove('flash');
    if(powerTimer <= 0){
      powerMode = false;
      barEl.classList.remove('flash');
      fillEl.style.width = '0%';
      ghosts.forEach(g => { if(g.state === 'vulnerable') g.state = 'normal'; });
    }
  }
}

/* ---------------- LIVES / GAMEOVER ---------------- */
function loseLife(){
  if(!gameActive) return;
  gameActive = false;
  lives--; updateHUD();
  if(lives <= 0){ gameOver(); return; }
  // reset positions (preserve eaten ghosts)
  pacman.x = 14 * TILE_SIZE; pacman.y = 23 * TILE_SIZE; pacman.direction = 'right'; pacman.nextDirection = 'right';
  ghosts.forEach((g,idx) => {
    if(g.state !== 'eaten'){
      g.x = (13 + idx) * TILE_SIZE; g.y = 11 * TILE_SIZE; g.state = 'normal';
      g.mode = 'scatter'; g.modeTimer = GHOST_SCATTER_DURATION;
    }
  });
  setTimeout(()=>{ gameActive = true; if(animationId) cancelAnimationFrame(animationId); animationId = requestAnimationFrame(gameLoop); }, 700);
}

function levelComplete(){ score += 1000; gameOver(true); }

function gameOver(win=false){
  gameActive = false;
  if(score > highScore){ highScore = score; localStorage.setItem('BlueManHighScore', highScore); }
  document.getElementById('finalScore').textContent = score;
  document.getElementById('gameOverTitle').textContent = win ? 'LEVEL COMPLETE!' : 'GAME OVER';
  document.getElementById('gameOver').classList.remove('hidden');
  updateHUD();
}

/* ---------------- MINT UI ---------------- */
function claimMint(){
  // Placeholder: connect this to your mint backend / Warpcast integration
  alert('Mint flow placeholder â€” integrate your Base mint endpoint here.');
  document.getElementById('mintBanner').classList.add('hidden');
}

/* ---------------- UTIL ---------------- */
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* ---------------- START ---------------- */
window.addEventListener('load', init);
</script>
</body>
</html>
